pragma solidity 0.4.24;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/lifecycle/Destructible.sol";

/**
  * @author James Spivey <spivey@zentostudios.com>
  * @title ReservationContract created by ReservationFactoryContract
  * @dev
  * This contract should not be created directly. This is designed to
  * be created by a factory that will manage each step of the reservation.
  */
contract ReservationContract is Destructible {
  using SafeMath for uint256;

  /*
    These are the events for all of the different states
    that this contract can be in. This will help the UI
    to update the list as these items occur. I dispatch
    here and in the factory itself for tracability.
  */
  event ReservationCreated(
    bytes32 id, address owner, address renter
  );
  event ReservationConfirmed(
    bytes32 id, address owner, address renter, address caller
  );
  event ReservationActive(
    bytes32 id, address owner, address renter, address caller
  );
  event ReservationCompleted(
    bytes32 id, address owner, address renter, address caller
  );
  event ReservationCanceled(
    bytes32 id, address owner, address renter, address caller
  );
  event ReservationDestroyed(
    bytes32 id, address owner, address renter
  );

  //Available contract states
  enum State { Created, Confirmed, Active, Completed, Canceled }

  //The reservation structure to cleanly pass around
  struct Reservation {
    bytes32 id; //Unique id generated by Factory
    address owner; //Address of the vehicle owner
    address renter; //Address of the renter
    uint8 nights; //Number of nights being rented
    uint256 rate; //Agreed rate at time of booking in wei
    uint256 totalValue; //Total value of reservation in wei
    uint256 createdDate; //Date reservation created
    uint256 startDate; //Date reservation begins
    uint256 endDate; //Date reservation ends
    uint256 paid; //Tracks the amount that has been paid from contract so far
  }

  //Expose state and the reservation data
  State public state = State.Created;
  Reservation public data;

  /** @dev Creates the reservation. This is called by the factory.
    *      it also takes the value as it is payable.
    * @param _totalValue Total value of reservation in wei
    * @param _renter Address of the renter
    * @param _id Unique id generated by Factory
    * @param _owner Address of the vehicle owner
    * @param _nights Number of nights being rented
    * @param _rate Agreed rate at time of booking in wei
    * @param _createdDate Date reservation created
    * @param _startDate Date reservation begins
    * @param _endDate Date reservation ends
    */
  constructor(
    uint256 _totalValue,
    address _renter,
    bytes32 _id,
    address _owner,
    uint8 _nights,
    uint256 _rate,
    uint256 _createdDate,
    uint256 _startDate,
    uint256 _endDate
  ) public payable {
    //Ensure the amount sent is enough to fill the reservation again
    require(
      msg.value == _totalValue,
      "Value sent does not equal reservation total cost"
    );
    //Ensure this was created by the factory. This is an extreme corner case
    require(
      msg.sender != _renter,
      "Vehicle renter can not create reservation"
    );
    require(
      msg.sender != _owner,
      "Vehicle owner can not create reservation"
    );

    //owner is set by Ownable.sol which Destructible.sol inherits
    //value comes from Factory
    data = Reservation({
      id: _id,
      owner: _owner,
      renter: _renter,
      nights: _nights,
      rate: _rate,
      totalValue: _totalValue,
      createdDate: _createdDate,
      startDate: _startDate,
      endDate: _endDate,
      paid: 0
    });
    emit ReservationCreated(data.id, data.owner, data.renter);
  }

  /** @dev Ensures only a vehicle owner can call */
  modifier onlyVehicleOwner(
    address _caller
  ) {
    require(
      _caller == data.owner,
      "Only owner can call this."
    );
    _;
  }

  /** @dev Ensures only a renter can call */
  modifier onlyVehicleRenter(
    address _caller
  ) {
    require(
      _caller == data.renter,
      "Only renter can call this."
    );
    _;
  }

  /** @dev Ensures only a vehicle owner or renter can call */
  modifier onlyContractMember(
    address _caller
  ) {
    require(
      _caller == data.renter || _caller == data.owner,
      "Only owner or renter can call this."
    );
    _;
  }

  /** @dev Ensures reservation is provided state
    * @param _state State to verify contract is in
    */
  modifier inState(
    State _state
  ) {
    require(
      state == _state,
      "Invalid state."
    );
    _;
  }

  /** @dev Called to confirm a reservation. Only the factory can call.
    *      it can only be called when in the Created state.
    * @param _caller The address of who called this from the factory. This must be the vehicle owner.
    */
  function accept(address _caller)
    public
    onlyOwner
    onlyVehicleOwner(_caller)
    inState(State.Created)
  {
    state = State.Confirmed;
    emit ReservationConfirmed(data.id, data.owner, data.renter, _caller);
  }

  /** @dev Called to start a reservation. Only the factory can call.
    *      It can only be called when in the Confirmed state. This pays
    *      half of the rental cost to the vehicle owner
    * @param _caller The address of who called this from the factory. This must be the vehicle owner.
    */
  function start(address _caller)
    public
    onlyOwner
    onlyVehicleOwner(_caller)
    inState(State.Confirmed)
  {
    state = State.Active;
    uint256 payment = SafeMath.div(data.totalValue, 2);

    //Ensure our payment has a value and our contract has enough ether
    require(payment != 0, "Payment must be greater than zero");
    require(
      address(this).balance / 2 >= payment,
      "Contract does not have enough ether for payment"
    );

    data.paid = payment;
    data.owner.transfer(data.paid);
    emit ReservationActive(data.id, data.owner, data.renter, _caller);
  }

  /** @dev Called to complete a reservation. Only the factory can call.
    *      it can only be called when in the Active state. This pays
    *      the last half of the rental cost to the vehicle owner.
    * @param _caller The address of who called this from the factory. This must be the vehicle renter.
    */
  function complete(address _caller)
    public
    onlyOwner
    onlyVehicleRenter(_caller)
    inState(State.Active)
  {
    state = State.Completed;
    uint256 payment = SafeMath.sub(data.totalValue, data.paid);

    //Ensure our payment has a value and our contract has enough ether
    require(payment != 0, "Payment must be greater than zero");
    require(
      address(this).balance >= payment,
      "Contract does not have enough ether for payment"
    );

    transferOwnership(data.owner);
    data.paid = SafeMath.add(data.paid, payment);
    data.owner.transfer(payment);
    emit ReservationCompleted(data.id, data.owner, data.renter, _caller);
  }

  /** @dev Called to cancel a reservation. Only the factory can call.
    *      It can only be called when in the Created state.
    * @param _caller The address of who called this from the factory. This must be the vehicle owner.
    */
  function cancel(address _caller)
    public
    onlyOwner
    onlyVehicleOwner(_caller)
    inState(State.Created)
  {
    state = State.Canceled;
    data.renter.transfer(data.totalValue);
    emit ReservationCanceled(data.id, data.owner, data.renter, _caller);
  }

  /** @dev Called to destroy a reservation. Anyone can call.
    *      It can only be called when in the Created state.
    *      This returns the ether to the renter.
    *      Not sure there is value in this with cancel as I want
    *      tracability in the contracts so not actually implemented yet.
    */
  function destroy(address _caller)
    public
    onlyContractMember(_caller)
    inState(State.Created)
  {
    emit ReservationDestroyed(data.id, data.owner, data.renter);
    destroyAndSend(data.renter); //This is provided by Destructible.sol
  }

  /** @dev Dont receive ether via fallback.
    * If this took extra ether then on destroyed
    * the renter would get ether they did not send/own possibly
    */
  function () public { }
}
